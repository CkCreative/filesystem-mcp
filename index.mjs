#!/usr/bin/env node
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { CallToolRequestSchema, ListToolsRequestSchema } from '@modelcontextprotocol/sdk/types.js';
import fs from 'fs-extra';
import path from 'path';
import { exec } from 'child_process';
import * as diffLib from 'diff';
import { fileURLToPath } from 'url';

// Get current file's directory
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Base directory for file operations
const BASE_DIR = process.env.MCP_BASE_DIR || process.cwd();
const PROJECT_FACTS_FILE = 'projectfacts.txt';

// For debugging - logs to stderr
const log = (...args) => console.error(...args);

log(`Starting Filesystem MCP Server in ${BASE_DIR}`);

// Initialize the MCP server
const server = new Server(
  {
    name: 'filesystem-mcp',
    version: '1.0.0',
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

// Set up handlers
server.setRequestHandler(ListToolsRequestSchema, async () => ({
  tools: [
    {
      name: 'createFile',
      description: 'Create a new file with specified content',
      inputSchema: {
        type: 'object',
        properties: {
          path: {
            type: 'string',
            description: 'Relative path to the file'
          },
          content: {
            type: 'string',
            description: 'Content to write to the file'
          },
          mode: {
            type: 'integer',
            description: 'File permissions (octal)',
            default: 0o644
          }
        },
        required: ['path', 'content'],
      },
    },
    {
      name: 'readFile',
      description: 'Read file content, optionally by line range',
      inputSchema: {
        type: 'object',
        properties: {
          path: {
            type: 'string',
            description: 'Relative path to the file'
          },
          startLine: {
            type: 'integer',
            description: 'Start line number (1-indexed)'
          },
          endLine: {
            type: 'integer',
            description: 'End line number (inclusive)'
          }
        },
        required: ['path'],
      },
    },
    {
      name: 'diffWithLLM',
      description: 'Compare an existing file with LLM-generated content',
      inputSchema: {
        type: 'object',
        properties: {
          filePath: {
            type: 'string',
            description: 'Relative path to the existing file'
          },
          llmContent: {
            type: 'string',
            description: 'Content generated by LLM to compare'
          },
          format: {
            type: 'string',
            description: 'Diff format (unified, json, html)',
            default: 'unified'
          }
        },
        required: ['filePath', 'llmContent'],
      },
    },
    {
      name: 'applyLLMChanges',
      description: 'Apply LLM-generated content to a file',
      inputSchema: {
        type: 'object',
        properties: {
          filePath: {
            type: 'string',
            description: 'Relative path to the file'
          },
          llmContent: {
            type: 'string',
            description: 'Content to apply to the file'
          },
          backup: {
            type: 'boolean',
            description: 'Create backup of original file',
            default: true
          }
        },
        required: ['filePath', 'llmContent'],
      },
    },
    {
      name: 'getProjectFacts',
      description: 'Get the project facts file content',
      inputSchema: {
        type: 'object',
        properties: {},
      },
    },
    {
      name: 'updateProjectFacts',
      description: 'Update the project facts file with a new entry',
      inputSchema: {
        type: 'object',
        properties: {
          filePath: {
            type: 'string',
            description: 'Relative path to the file'
          },
          description: {
            type: 'string',
            description: 'Description of the file'
          }
        },
        required: ['filePath'],
      },
    },
    {
      name: 'executeCommand',
      description: 'Execute a whitelisted command',
      inputSchema: {
        type: 'object',
        properties: {
          command: {
            type: 'string',
            description: 'Command to execute'
          },
          args: {
            type: 'array',
            items: { type: 'string' },
            description: 'Command arguments'
          },
          workingDir: {
            type: 'string',
            description: 'Working directory'
          }
        },
        required: ['command'],
      },
    },
  ],
}));

// Handle tool calls
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  try {
    switch (request.params.name) {
      case 'createFile':
        return await handleCreateFile(request.params.arguments);
      case 'readFile':
        return await handleReadFile(request.params.arguments);
      case 'diffWithLLM':
        return await handleDiffWithLLM(request.params.arguments);
      case 'applyLLMChanges':
        return await handleApplyLLMChanges(request.params.arguments);
      case 'getProjectFacts':
        return await handleGetProjectFacts();
      case 'updateProjectFacts':
        return await handleUpdateProjectFacts(request.params.arguments);
      case 'executeCommand':
        return await handleExecuteCommand(request.params.arguments);
      default:
        return {
          content: [
            {
              type: 'text',
              text: `Unknown tool: ${request.params.name}`,
            },
          ],
          isError: true,
        };
    }
  } catch (error) {
    console.error(`Error in tool handler: ${error.message}`);
    return {
      content: [
        {
          type: 'text',
          text: `Error: ${error.message}`,
        },
      ],
      isError: true,
    };
  }
});

// Ensure path is within allowed directories
function isPathAllowed(filePath) {
  const normalizedPath = path.normalize(filePath);
  const absolutePath = path.resolve(BASE_DIR, normalizedPath);
  return absolutePath.startsWith(BASE_DIR);
}

// Get absolute path from relative path
function getAbsolutePath(relativePath) {
  return path.resolve(BASE_DIR, path.normalize(relativePath));
}

// Handle createFile
async function handleCreateFile({ path: filePath, content, mode = 0o644 }) {
  if (!filePath) {
    throw new Error('Path is required');
  }

  if (!isPathAllowed(filePath)) {
    throw new Error('Path not allowed');
  }

  log(`Creating file: ${filePath}`);
  const absolutePath = getAbsolutePath(filePath);

  // Create directories if they don't exist
  await fs.ensureDir(path.dirname(absolutePath));

  // Write file with specified content
  await fs.writeFile(absolutePath, content || '', { mode });

  // Update project facts
  await updateProjectFacts({
    filePath,
    description: `Created by MCP on ${new Date().toISOString()}`
  });

  return {
    content: [
      {
        type: 'text',
        text: `File created successfully: ${filePath}`,
      },
    ],
  };
}

// Handle readFile
async function handleReadFile({ path: filePath, startLine, endLine }) {
  if (!filePath) {
    throw new Error('Path is required');
  }

  if (!isPathAllowed(filePath)) {
    throw new Error('Path not allowed');
  }

  log(`Reading file: ${filePath}`);
  const absolutePath = getAbsolutePath(filePath);

  if (!(await fs.pathExists(absolutePath))) {
    throw new Error(`File does not exist: ${filePath}`);
  }

  const content = await fs.readFile(absolutePath, 'utf8');
  const lines = content.split('\n');

  let resultContent;
  let resultMessage = `File: ${filePath}`;

  if (startLine !== undefined && endLine !== undefined) {
    resultContent = lines.slice(Math.max(0, startLine - 1), endLine).join('\n');
    resultMessage += `\nDisplaying lines ${startLine} to ${endLine} of ${lines.length}`;
  } else {
    resultContent = content;
    resultMessage += `\nTotal lines: ${lines.length}`;
  }

  return {
    content: [
      {
        type: 'text',
        text: `${resultMessage}\n\nContent:\n${resultContent}`,
      },
    ],
  };
}

// Handle diffWithLLM
async function handleDiffWithLLM({ filePath, llmContent, format = 'unified' }) {
  if (!filePath) {
    throw new Error('File path is required');
  }

  if (!llmContent) {
    throw new Error('LLM content is required');
  }

  if (!isPathAllowed(filePath)) {
    throw new Error('Path not allowed');
  }

  log(`Diffing file: ${filePath}`);
  const absolutePath = getAbsolutePath(filePath);

  let originalContent = '';
  if (await fs.pathExists(absolutePath)) {
    originalContent = await fs.readFile(absolutePath, 'utf8');
  }

  let diffResult;

  // Generate diff based on format
  if (format === 'unified') {
    diffResult = diffLib.createPatch(
      filePath,
      originalContent,
      llmContent,
      'Original',
      'LLM Generated'
    );
  } else if (format === 'json') {
    const diffArray = diffLib.diffLines(originalContent, llmContent);
    diffResult = JSON.stringify(
      diffArray.map(part => ({
        value: part.value,
        added: part.added || false,
        removed: part.removed || false
      })),
      null,
      2
    );
  } else if (format === 'html') {
    const diffArray = diffLib.diffLines(originalContent, llmContent);
    let html = '<div class="diff">';

    diffArray.forEach(part => {
      const color = part.added ? 'green' : part.removed ? 'red' : 'grey';
      const spanClass = part.added ? 'added' : part.removed ? 'removed' : 'unchanged';
      html += `<span class="${spanClass}" style="color:${color}">${escapeHtml(part.value)}</span>`;
    });

    html += '</div>';
    diffResult = html;
  } else {
    throw new Error(`Unsupported diff format: ${format}`);
  }

  return {
    content: [
      {
        type: 'text',
        text: `Diff between original file and LLM content (${format} format):\n\n${diffResult}`,
      },
    ],
  };
}

function escapeHtml(text) {
  return text
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;")
    .replace(/\n/g, "<br>");
}

// Handle applyLLMChanges
async function handleApplyLLMChanges({ filePath, llmContent, backup = true }) {
  if (!filePath) {
    throw new Error('File path is required');
  }

  if (llmContent === undefined) {
    throw new Error('LLM content is required');
  }

  if (!isPathAllowed(filePath)) {
    throw new Error('Path not allowed');
  }

  log(`Applying changes to file: ${filePath}`);
  const absolutePath = getAbsolutePath(filePath);

  // Create backup if requested and file exists
  let backupFilePath = null;
  if (backup && await fs.pathExists(absolutePath)) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    backupFilePath = `${absolutePath}.${timestamp}.backup`;
    await fs.copy(absolutePath, backupFilePath);
  }

  // Ensure directory exists
  await fs.ensureDir(path.dirname(absolutePath));

  // Apply LLM changes by writing content
  await fs.writeFile(absolutePath, llmContent);

  // Update project facts
  await updateProjectFacts({
    filePath,
    description: `Updated by LLM via MCP on ${new Date().toISOString()}`
  });

  return {
    content: [
      {
        type: 'text',
        text: `Changes applied to ${filePath} successfully.\n` +
             (backupFilePath ? `Backup created at: ${path.relative(BASE_DIR, backupFilePath)}` : 'No backup was created.'),
      },
    ],
  };
}

// Handle getProjectFacts
async function handleGetProjectFacts() {
  const projectFactsPath = getAbsolutePath(PROJECT_FACTS_FILE);

  if (!(await fs.pathExists(projectFactsPath))) {
    return {
      content: [
        {
          type: 'text',
          text: "Project facts file doesn't exist yet. It will be created when files are added.",
        },
      ],
    };
  }

  const content = await fs.readFile(projectFactsPath, 'utf8');

  return {
    content: [
      {
        type: 'text',
        text: `Project Facts:\n\n${content}`,
      },
    ],
  };
}

// Update project facts
async function updateProjectFacts({ filePath, description = '' }, isDelete = false) {
  if (!filePath) {
    throw new Error('File path is required');
  }

  const projectFactsPath = getAbsolutePath(PROJECT_FACTS_FILE);

  // Ensure project facts file exists
  if (!(await fs.pathExists(projectFactsPath))) {
    const header = "# Project Facts - Files and Descriptions\n\n";
    await fs.writeFile(projectFactsPath, header);
  }

  // Read current project facts
  const currentContent = await fs.readFile(projectFactsPath, 'utf8');

  // Create entry
  const fileEntry = `- ${filePath}: ${description || 'No description provided'}`;

  // Process current content lines
  const lines = currentContent.split('\n');
  const updatedLines = [];
  let found = false;

  for (const line of lines) {
    // Check if line contains the file path
    if (line.startsWith(`- ${filePath}:`)) {
      found = true;
      if (!isDelete) {
        updatedLines.push(fileEntry);
      }
    } else {
      updatedLines.push(line);
    }
  }

  // Add new entry if not found and not deleting
  if (!found && !isDelete) {
    updatedLines.push(fileEntry);
  }

  // Write updated content
  await fs.writeFile(projectFactsPath, updatedLines.join('\n'));

  return {
    success: true,
    file: PROJECT_FACTS_FILE
  };
}

// Handle updateProjectFacts
async function handleUpdateProjectFacts({ filePath, description }) {
  if (!filePath) {
    throw new Error('File path is required');
  }

  await updateProjectFacts({ filePath, description });

  return {
    content: [
      {
        type: 'text',
        text: `Project facts updated for file: ${filePath}`,
      },
    ],
  };
}

// Handle executeCommand
async function handleExecuteCommand({ command, args = [], workingDir, timeout = 30000 }) {
  if (!command) {
    throw new Error('Command is required');
  }

  // Whitelist allowed commands
  const allowedCommands = ['git', 'grep', 'find', 'ls', 'cat', 'diff', 'mkdir', 'rm', 'cp', 'mv'];
  if (!allowedCommands.includes(command)) {
    throw new Error(`Command not allowed: ${command}`);
  }

  // Validate working directory if specified
  let cwd = process.cwd();
  if (workingDir) {
    if (!isPathAllowed(workingDir)) {
      throw new Error('Working directory not allowed');
    }
    cwd = getAbsolutePath(workingDir);
  }

  // Sanitize arguments to prevent command injection
  const sanitizedArgs = args.map(arg => {
    // Simple sanitization - in production, use a more robust method
    return String(arg).replace(/[;&|()<>$`\\]/g, '');
  });

  log(`Executing command: ${command} ${sanitizedArgs.join(' ')}`);

  return new Promise((resolve) => {
    const options = {
      cwd,
      timeout,
      maxBuffer: 1024 * 1024 * 10, // 10MB output buffer
    };

    exec(`${command} ${sanitizedArgs.join(' ')}`, options,
      (error, stdout, stderr) => {
        if (error && error.code !== 0) {
          // Don't reject for non-zero exit codes, just include in response
          return resolve({
            content: [
              {
                type: 'text',
                text: `Command executed with exit code ${error.code}.\n\nOutput:\n${stdout}\n\nErrors:\n${stderr}`,
              },
            ],
          });
        }

        resolve({
          content: [
            {
              type: 'text',
              text: `Command executed successfully.\n\nOutput:\n${stdout}${stderr ? `\n\nErrors:\n${stderr}` : ''}`,
            },
          ],
        });
      });
  });
}

// Start MCP server
console.error('Filesystem MCP server starting...');
const transport = new StdioServerTransport();
server.connect(transport);
console.error('Filesystem MCP server ready');
