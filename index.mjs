#!/usr/bin/env node
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { z } from 'zod';
import path from 'path';
import { fileURLToPath } from 'url';

// Config and logging
import { log, BASE_DIR, READ_ONLY_MODE } from './src/config.mjs';

// Handlers
import {
  createFileHandler, readFileHandler, deletePathHandler, listDirectoryHandler,
  movePathHandler, createDirectoryHandler, getFileMetadataHandler
} from './src/handlers/fileOpsHandlers.mjs';
import {
  diffWithLLMHandler, applyLLMChangesHandler, searchInFilesHandler, replaceInFileHandler
} from './src/handlers/contentOpsHandlers.mjs';
import {
  getProjectFactsHandler, updateProjectFactDescriptionHandler, getProjectStructureHandler, clearProjectFactsHandler
} from './src/handlers/projectCtxHandlers.mjs';
import { executeCommandHandler } from './src/handlers/commandOpsHandlers.mjs';
import { getEnvironmentInfoHandler } from './src/handlers/utilityHandlers.mjs';
import {
  getDiagnosticsHandler, getCompletionsHandler, findDefinitionHandler, formatDocumentHandler, languageIdSchema
} from './src/handlers/lspOpsHandlers.mjs';
import lspService from './src/lsp/lspService.mjs'; // Import to ensure it's initialized and for shutdown

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

log(`Starting Filesystem MCP Server (v${(await import('./package.json', { assert: { type: 'json' } })).default.version})`);
log(`Base Directory: ${BASE_DIR}`);
if (READ_ONLY_MODE) {
  log('SERVER IS IN READ-ONLY MODE. Destructive operations will be blocked.');
}

const server = new McpServer({
  name: 'filesystem-mcp-ex', // ex for extended
  version: (await import('./package.json', { assert: { type: 'json' } })).default.version,
});

// --- File Operations Tools ---
server.tool(
  'createFile',
  {
    path: z.string().describe('Relative path to the file within the project directory.'),
    content: z.string().describe('Content to write to the file.'),
    mode: z.number().int().optional().default(0o644).describe('File permissions (octal, e.g., 0o644).'),
  },
  createFileHandler
);

server.tool(
  'readFile',
  {
    path: z.string().describe('Relative path to the file.'),
    startLine: z.number().int().min(1).optional().describe('Start line number (1-indexed).'),
    endLine: z.number().int().min(1).optional().describe('End line number (inclusive).'),
  },
  readFileHandler
);

server.tool(
  'deletePath',
  {
    path: z.string().describe('Relative path to the file or directory to delete.'),
    recursive: z.boolean().optional().default(false).describe('If true, allows deletion of non-empty directories.'),
  },
  deletePathHandler
);

server.tool(
  'listDirectory',
  {
    path: z.string().optional().default('.').describe('Relative path to the directory to list. Defaults to project root.'),
    recursive: z.boolean().optional().default(false).describe('Whether to list recursively.'),
    showDetails: z.boolean().optional().default(false).describe('Include details like size, type, last modified, permissions.'),
    maxDepth: z.number().int().min(1).max(10).optional().default(5).describe('Maximum recursion depth if recursive is true.'),
  },
  listDirectoryHandler
);

server.tool(
  'movePath',
  {
    sourcePath: z.string().describe('Relative path to the source file or directory.'),
    destinationPath: z.string().describe('Relative path for the destination.'),
    overwrite: z.boolean().optional().default(false).describe('If true, overwrite destination if it exists.'),
  },
  movePathHandler
);

server.tool(
  'createDirectory',
  {
    path: z.string().describe('Relative path for the new directory.'),
    recursive: z.boolean().optional().default(true).describe('If true, create parent directories as needed.'),
  },
  createDirectoryHandler
);

server.tool(
  'getFileMetadata',
  {
    path: z.string().describe('Relative path to the file or directory.'),
  },
  getFileMetadataHandler
);

// --- Content Manipulation & Search Tools ---
server.tool(
  'diffWithLLM',
  {
    filePath: z.string().describe('Relative path to the existing file (or path for new file).'),
    llmContent: z.string().describe('Content generated by LLM to compare.'),
    format: z.enum(['unified', 'json', 'html']).optional().default('unified').describe('Diff format.'),
  },
  diffWithLLMHandler
);

server.tool(
  'applyLLMChanges',
  {
    filePath: z.string().describe('Relative path to the file.'),
    llmContent: z.string().describe('Content to apply to the file.'),
    backup: z.boolean().optional().default(true).describe('Create a timestamped backup of the original file if it exists.'),
  },
  applyLLMChangesHandler
);

server.tool(
  'searchInFiles',
  {
    searchTerm: z.string().describe('The string or regex pattern to search for.'),
    directoryPath: z.string().optional().default('.').describe('Relative path to the directory to search within. Defaults to project root.'),
    filePattern: z.string().optional().default('**/*').describe('Glob pattern for files to search (e.g., "*.js", "src/**/*.ts"). Defaults to all files recursively.'),
    isRegex: z.boolean().optional().default(false).describe('Whether searchTerm is a regular expression.'),
    caseSensitive: z.boolean().optional().default(false).describe('Perform a case-sensitive search.'),
    recursive: z.boolean().optional().default(true).describe('Search recursively. If false, only searches top-level of directoryPath.'),
  },
  searchInFilesHandler
);

server.tool(
  'replaceInFile',
  {
    filePath: z.string().describe('Relative path to the file.'),
    searchTerm: z.string().describe('Text or regex pattern to find.'),
    replacementText: z.string().describe('Text to replace with.'),
    isRegex: z.boolean().optional().default(false).describe('Whether searchTerm is a regular expression.'),
    replaceAll: z.boolean().optional().default(true).describe('Replace all occurrences or just the first.'),
    caseSensitive: z.boolean().optional().default(false).describe('Perform a case-sensitive search/replace.'),
    backup: z.boolean().optional().default(true).describe('Create a timestamped backup of the original file.'),
  },
  replaceInFileHandler
);

// --- Project Context & Management Tools ---
server.tool(
  'getProjectFacts',
  {},  // No parameters needed
  getProjectFactsHandler
);

server.tool(
  'updateProjectFactDescription',
  {
    filePath: z.string().describe('Relative path to the file being described.'),
    description: z.string().describe('Description of the file or a recent change/purpose.'),
  },
  updateProjectFactDescriptionHandler
);

server.tool(
  'getProjectStructure',
  {
    directoryPath: z.string().optional().default('.').describe('Relative path to start building the structure from. Defaults to project root.'),
    maxDepth: z.number().int().min(1).max(10).optional().default(5).describe('Maximum depth to recurse.'),
  },
  getProjectStructureHandler
);

server.tool(
  'clearProjectFacts',
  {},  // No parameters needed
  clearProjectFactsHandler
);

// --- Command Execution Tools ---
server.tool(
  'executeCommand',
  {
    command: z.string().describe(`The whitelisted command to execute (e.g., 'git', 'ls').`),
    args: z.array(z.string()).optional().default([]).describe('Arguments for the command.'),
    workingDirRel: z.string().optional().describe('Relative path from project root to set as the working directory. Defaults to project root.'),
    stdinContent: z.string().optional().describe('Content to pass to the command via stdin.'),
    timeout: z.number().int().min(1000).optional().describe(`Timeout in milliseconds. Defaults to server config.`),
  },
  executeCommandHandler
);

// --- Utility Tools ---
server.tool(
  'getEnvironmentInfo',
  {},  // No parameters needed
  getEnvironmentInfoHandler
);

// --- Language Server Protocol (LSP) Tools ---
server.tool(
  'getDiagnostics',
  {
    filePath: z.string().describe('Relative path to the file within the project directory.'),
    // languageId: languageIdSchema, // languageId can often be inferred by LSP from file extension
  },
  getDiagnosticsHandler
);

server.tool(
  'getCompletions',
  {
    filePath: z.string().describe('Relative path to the file.'),
    // languageId: languageIdSchema,
    line: z.number().int().min(0).describe('Line number for completions (0-indexed).'),
    character: z.number().int().min(0).describe('Character offset on the line for completions (0-indexed).'),
  },
  getCompletionsHandler
);

server.tool(
  'findDefinition',
  {
    filePath: z.string().describe('Relative path to the file.'),
    // languageId: languageIdSchema,
    line: z.number().int().min(0).describe('Line number of the symbol (0-indexed).'),
    character: z.number().int().min(0).describe('Character offset of the symbol (0-indexed).'),
  },
  findDefinitionHandler
);

server.tool(
  'formatDocument',
  {
    filePath: z.string().describe('Relative path to the file to format.'),
    // languageId: languageIdSchema, // Optional, can be inferred
  },
  formatDocumentHandler
);

// Connect to transport with proper async/await handling
const transport = new StdioServerTransport();
try {
  await server.connect(transport);
  log('Filesystem MCP Server connected to transport and ready.');
} catch (error) {
  log('Failed to connect server to transport:', error);
  process.exit(1);
}

async function shutdownGracefully() {
  log('Received shutdown signal, shutting down server and LSPs...');
  server.close();
  transport.close();
  if (lspService) { // Check if lspService is defined
    await lspService.shutdownAll();
  }
  log('Shutdown complete.');
  process.exit(0);
}

process.on('SIGINT', () => {
  shutdownGracefully();
});

process.on('SIGTERM', () => {
  shutdownGracefully();
});
